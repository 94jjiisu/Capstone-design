## 해결해야할 문제
### 1. 체비쇼프 거리를 사용하시 때문에 현 상황에선 좀비가 플레이어를 추적하고 있다면 플레이어가 벽을 마주하는 순간 100% 죽음. 
(1)게임진행 빨리하기 위해 그냥 현상황 유지  
(2)좀비는 5턴에 한 번 쉬는 구조로 하여 좀비 이동에 패널티 주기  
(3) 플레이어 시야를 좀비 시야보다 넓게 만들어서 사전에 움직일 수 있도록 하기  
- 불쌍한 플레이어는 너무 많이 뜯어 먹히고 있다ㅠ
- 일요일 점심즈음에는 문제가 많이 해결된 상태일테니 밥을 먹으며 논의하면 될 것 같다

### 2. 맵 외 아이템, 플레이어, 좀비 numpy로 구현하는 문제
- 제는 generate과 step에서 point_checker를 이용해 imp_points에 좀비, 플레이어, 아이템, 벽 위치를 넣을 때 numpy array로 구현된 벽 array를 다시 list로 바꾸게 한 상태이다. 그냥 이렇게 끝내는게 좋은지, 좀비, 플레이어, 아이템 list도 numpy array로 바꾸는게 나은지 고민입니다... 후자가 된다면 generate 방식도 바꾸고 좀 이것저것 수정할거같아요(급한건 아니고)

### 3. 초기 가중치의 문제
- 대체 왜 1세대가 이렇게 똑똑한거지?
- 빛나는 통찰력을 기다리며...
- 2020년 5월 1일 새벽에 남태수가 수정한 game파일을 실행해보면 알 수 있듯이 플레이어는 시간이 지남에 따라 벽으로 붙어서 존버하려는 경향을 나타내고있음.
- 존버하려는 벽의 방향은 초기 세대가 우연히 어떤 구석탱이로 가서 오래 살아남았는지가 좌우하는 것으로 보임
- 적합도 함수에서 아이템 획득 횟수에 3000을 곱해도 해결되지 않는 문제임
- 뉴럴넷 상에서 해결해야할 문제이므로 지수님께서 최적화 문제를 고려하실 때 이에관한 해결책을 고민하실 필요가 있을 것 같습니다

### 4. 해결한 문제 5의 심화
- 플레이어즈 리스트에서 삭제한다고해서 플레이어가 말끔하게 삭제되지 않은것일 수 있다. 현재 코드에는 문제가 없지만 메모리 누수는 분명한 문제이므로 가능하다면 말끔하게 삭제된 것인지 확인하고, 삭제되지 않았다면 이를 삭제할 수 있는 코드까지 짜는 것이 좋을 것 같다.

## 해결한 문제
### 1. 문워크 문제 20200430 1:23AM
- 파이게임의 화면 출력시 좌표계 불일치로 문제가 발생한 경우임  
- 위아래가 반전되어 표시되므로 self.DIRECTIONS의 y좌표 부호를 반대로 바꾸어 문제해결  
- 나이쏴 나이쏴 코딩은 맥주가 반이다!  

### 2. 유전 적용의 문제 20200501 6:30AM
- 기존 유전알고리즘의 경우 deepcopy를 사용했으나 클래스는 deepcopy를 해도 view로 적용된다는점, pygame의 sprite사용으로 인해 deepcopy와 상호작용 자체가 불가능하다는 점때문에 deepcopy를 사용한 모든 부분을 수정함
- GA에 copy 적용이 불가능해짐에 따라 클래스를 구현한 소스코드의 __init__부분을 대부분 generate 메소드로 옮김. 작동하는 데엔 문제가 없는 것 확인

### 3. 적합도 함수에 적용하는 과거, 현재 dist 비교 메소드 추가 20200501 6:30AM
- 속성은 플레이어의 센서 내부에다가 구현완료 메소드 구현도 작업 완료
- 대충 봤을때는 있을 때와 없을 때의 효력을 확인하기 어려움
- 일단은 아이템에서 멀어질 때 페널티를 얻는 형식으로 구현함
- 아이템에 가까워지기만 해도 step이 오른다면 현재 벽에 붙어서 와리가리만 하는 플레이어들의 행동성향이 더 짙어질수도 있을 것 같기 때문

### 4. move함수로 인한 중복문제 20200501 6:30AM
- 이전 버전처럼 move과정을 하나의 함수로 구현하면, 함수호출 당시에 받았던 플레이어와 좀비의 위치정보를 활용하므로 각개체가 실시간으로 좌표정보(특히, imp_points)를 갱신할 수 없다. 따라서, 그냥 3단계의 메소드를 game자체에 순차적으로 적어주었다.

### 5. 좀비가 한동안 움직이지 않던 문제 20200501 8:14AM
- 닭쫓던 개 지붕 쳐다보기... : 좀비가 멈추는 현상은 심도있는 print를 통한 디버깅 결과 target특정에 있었다. 예를 들어 3명의 좀비가 1명의 동일한 player를 쫓고 있던 경우, player와 충돌이 일어나게되면 player는 players리스트에서 삭제된다. 문제는 리스트에서삭제된다고해서 zombie들이 target을 None으로 자동변경하지 않는다는 것이다. 메모리를 직접 살펴볼 수 없어 확실한 판단은 불가하지만 players list에서 사라진다고해서 player가 말끔히 사라지는 것은 아닌 것 같다. 그 3명의 좀비들은 모두 이전에 player가 죽었던 장소를 target으로 저장하며 움직이지 않고 있었다. 이를 해결하기위해 player를 쫓던 놈들이 해당 target을 잃으면 target을 None으로 지정하도록 명시했다.

### 6. 플레이어가 좀비에게 먹힐 때 중복해서 player를 삭제하거나 과도하게 zombie가 생성되는 경우 20200501 8:14AM
- 2명의 좀비가 동시에 1명의 플레이어를 잡는다거나 2명의 플레이어가 1명의 좀비에게 동시에 잡히는 일이 발생했다. 이에 대응하기 위해 dead_players list를 다루는 기존의 코드를 수정하고 이 때 zombie를 추가하는 과정도 조금 수정했다.

### 7. 맵 numpy로 구현 20200503 3:30
- for문을 돌며 list에 append하는 방식에서 numpy array로 

## 수정사항
### 1. self.limit_of_stpes를 추가하여 플레이어마다 한계 스텝을 갖도록 했다. 20200501 8:14AM
- 기존 3000으로 명시하던 것에서 변화한 것은 다음과 같다. 아이템을 먹으면 스텝을 줄여주는 것이 아니라 한계 스텝을 늘려주고 아이템 획득 횟수를 늘려준다. 따라서 모든 플레이어에 대하여 같은 숫자(limit steps)로 해당 객체의 step을 비교하는 것이 아니라 해당 객체의 limit of steps와 해당 객체의 steps를 비교하여 자연사한것인지 아닌지를 판단한다. 아이템을 먹은 플레이어는 수명이 늘어나 장수할 수 있게 수정했다고 보면 됨.
